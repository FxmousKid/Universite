                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       

********** à remplir obligatoirement **********

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: le vendredi 25 octobre 2024 à 19:00

Identité
--------
Nombre de binôme: 55
Nom, prénom 1: NAZARIAN, IYAN
Nom, prénom 2: POLGAR, THEO


Questions sur votre code
------------------------
0. Avez-vous testé que `dune build` s'exécute sans erreurs ou warnings,
   et que ensuite `dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, il n'y a que les warnings habituels et sudoku-4x4.cnf marche.
---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, via ```filter_map simpl_clause clauses```. Le helper ```simpl_clause``` renvoie ```None```
pour les clauses satisfaites par ```l``` (elles sont supprimé) et ```Some clause_sans_neg```
pour les autres après extraction du litteral opposer ```-l```.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

**Une fonction récursive ```find``` parcourt les clauses ; dès qu'elle rencontre une 
clause ```[literal]```, elle renvoie ```Some literal```, sinon elle poursuit sur la suite. On n'a pas eu besoin
d'autre helper.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

List.concat pour mettre tous les litteraux au meme niveau (flatten), 
puis une fonction récursive `find` combiner a ```List.exists (fun x -> x = -l)```
pour tester la présence de l'opposé. On renvoie le premier littéral qui n'a pas son contraire.

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

Toutes formules possédant un unitaire ou un pur, car `solveur_dpll_rec` va d'abord chercher les clauses unitaires et
ensuite les litteraux purs alors que `solveur_split` teste n'importe quel litteral à la suite.

---
5. Quelle a été votre méthodologie de test ?

Approche similaire TDD pour les fonctions auxiliaire : ajout progressif de tests `let %test` pour `simplifie`, `pur`, `unitaire`. Tests globaux (build, exécution DIMACS) prévus après finalisation du solveur.

---
6. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

(iyan : ca aurait eté judicieux de faire le projet avant le partielle (╥‸╥) )
Projet tres interressant mais manque de coq...
**à remplir**

---

--fin du fichier RENDU--
